<!-- HTML header for doxygen 1.14.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CSpaceEngine: 解方程</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script type="text/javascript" src="../../darkmode_toggle.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CSpaceEngine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','搜索',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d9/deb/group___math_solve_poly.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">类</a> &#124;
<a href="#typedef-members">类型定义</a> &#124;
<a href="#func-members">函数</a>  </div>
  <div class="headertitle"><div class="title">解方程<div class="ingroups"><a class="el" href="../../d9/ded/group___base.html">基本</a> &raquo; <a class="el" href="../../d4/d7d/group___math_funcs.html">数学函数</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>实现从一次到高次多项式方程的求解算法  
<a href="#details">更多...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
类</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db7/struct_solve_poly_routine.html">SolvePolyRoutine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">多项式求解算法接口  <a href="../../d2/db7/struct_solve_poly_routine.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d03/class_durand_kerner_solve_poly.html">DurandKernerSolvePoly</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">杜兰德-肯纳多项式求解器实现  <a href="../../d6/d03/class_durand_kerner_solve_poly.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
类型定义</h2></td></tr>
<tr class="memitem:gaa363dcb20a57d00274808e3cf92306aa" id="r_gaa363dcb20a57d00274808e3cf92306aa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa363dcb20a57d00274808e3cf92306aa">InputArray</a> = const std::vector&lt;float64&gt;&amp;</td></tr>
<tr class="memdesc:gaa363dcb20a57d00274808e3cf92306aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">输入系数数组类型  <br /></td></tr>
<tr class="separator:gaa363dcb20a57d00274808e3cf92306aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cf635a645a56aeaca963fd40dc340e6" id="r_ga0cf635a645a56aeaca963fd40dc340e6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0cf635a645a56aeaca963fd40dc340e6">OutputArray</a> = std::vector&lt;complex64&gt;&amp;</td></tr>
<tr class="memdesc:ga0cf635a645a56aeaca963fd40dc340e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">输出解数组类型  <br /></td></tr>
<tr class="separator:ga0cf635a645a56aeaca963fd40dc340e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
函数</h2></td></tr>
<tr class="memitem:ga1dbba6e1fd68071c003a0f150b67c835" id="r_ga1dbba6e1fd68071c003a0f150b67c835"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1dbba6e1fd68071c003a0f150b67c835">__Verify_Input_Output</a> (<a class="el" href="#gaa363dcb20a57d00274808e3cf92306aa">InputArray</a> Coeffs, <a class="el" href="#ga0cf635a645a56aeaca963fd40dc340e6">OutputArray</a> Roots, uint64 Power) noexcept(0)</td></tr>
<tr class="memdesc:ga1dbba6e1fd68071c003a0f150b67c835"><td class="mdescLeft">&#160;</td><td class="mdescRight">验证输入输出参数的有效性  <br /></td></tr>
<tr class="separator:ga1dbba6e1fd68071c003a0f150b67c835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3267fd69bd6b80868acf5e0a758972ec" id="r_ga3267fd69bd6b80868acf5e0a758972ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3267fd69bd6b80868acf5e0a758972ec">SolveLinear</a> (<a class="el" href="#gaa363dcb20a57d00274808e3cf92306aa">InputArray</a> Coeffs, <a class="el" href="#ga0cf635a645a56aeaca963fd40dc340e6">OutputArray</a> Roots)</td></tr>
<tr class="memdesc:ga3267fd69bd6b80868acf5e0a758972ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">求解一元一次方程 \(ax + b = 0\)  <br /></td></tr>
<tr class="separator:ga3267fd69bd6b80868acf5e0a758972ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab22ac94f160103ac9e24bdee8852b776" id="r_gab22ac94f160103ac9e24bdee8852b776"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab22ac94f160103ac9e24bdee8852b776">SolveQuadratic</a> (<a class="el" href="#gaa363dcb20a57d00274808e3cf92306aa">InputArray</a> Coeffs, <a class="el" href="#ga0cf635a645a56aeaca963fd40dc340e6">OutputArray</a> Roots)</td></tr>
<tr class="memdesc:gab22ac94f160103ac9e24bdee8852b776"><td class="mdescLeft">&#160;</td><td class="mdescRight">求解一元二次方程 \(ax^2 + bx + c = 0\)  <br /></td></tr>
<tr class="separator:gab22ac94f160103ac9e24bdee8852b776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e4e4b1a7a18ee56d164319191c2b508" id="r_ga9e4e4b1a7a18ee56d164319191c2b508"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9e4e4b1a7a18ee56d164319191c2b508">SolveCubic</a> (<a class="el" href="#gaa363dcb20a57d00274808e3cf92306aa">InputArray</a> Coeffs, <a class="el" href="#ga0cf635a645a56aeaca963fd40dc340e6">OutputArray</a> Roots, float64 Tolerence=10)</td></tr>
<tr class="memdesc:ga9e4e4b1a7a18ee56d164319191c2b508"><td class="mdescLeft">&#160;</td><td class="mdescRight">求解一元三次方程 \(ax^3 + bx^2 + cx + d = 0\) (范盛金算法)  <br /></td></tr>
<tr class="separator:ga9e4e4b1a7a18ee56d164319191c2b508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95ba492f7b6d313d1b3eafd733cb1a56" id="r_ga95ba492f7b6d313d1b3eafd733cb1a56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga95ba492f7b6d313d1b3eafd733cb1a56">SolveQuartic</a> (<a class="el" href="#gaa363dcb20a57d00274808e3cf92306aa">InputArray</a> Coeffs, <a class="el" href="#ga0cf635a645a56aeaca963fd40dc340e6">OutputArray</a> Roots, float64 Tolerence=10)</td></tr>
<tr class="memdesc:ga95ba492f7b6d313d1b3eafd733cb1a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">求解一元四次方程 \(ax^4 + bx^3 + cx^2 + dx + e = 0\) (沈天珩算法)  <br /></td></tr>
<tr class="separator:ga95ba492f7b6d313d1b3eafd733cb1a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f1f3b4fba5ba76a9c268acb0cbdd7ba" id="r_ga7f1f3b4fba5ba76a9c268acb0cbdd7ba"><td class="memItemLeft" align="right" valign="top">uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7f1f3b4fba5ba76a9c268acb0cbdd7ba">SolvePoly</a> (<a class="el" href="#gaa363dcb20a57d00274808e3cf92306aa">InputArray</a> Coeffs, <a class="el" href="#ga0cf635a645a56aeaca963fd40dc340e6">OutputArray</a> Roots, const <a class="el" href="../../d2/db7/struct_solve_poly_routine.html">SolvePolyRoutine</a> &amp;Routine=<a class="el" href="../../d6/d03/class_durand_kerner_solve_poly.html">DurandKernerSolvePoly</a>())</td></tr>
<tr class="memdesc:ga7f1f3b4fba5ba76a9c268acb0cbdd7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">通用多项式求解函数  <br /></td></tr>
<tr class="separator:ga7f1f3b4fba5ba76a9c268acb0cbdd7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<p>实现从一次到高次多项式方程的求解算法 </p>
<p>求解由以下形式定义的多项式方程的解(降幂排序)： </p><p class="formulaDsp">
\[\sum^{n}_{i=0} (a_i \cdot x^{n - i - 1}) = 0\]
</p>
<p>其中： <br  />
</p><ul>
<li>一次和二次方程使用求根公式 <br  />
</li>
<li>三次方程使用范盛金算法 <br  />
</li>
<li>四次方程使用沈天珩算法 <br  />
</li>
<li>五次及以上使用杜兰德-肯纳迭代 <br  />
 </li>
</ul>


<h3><a id="SolvePolyHistory" name="SolvePolyHistory"></a>一些碎碎念</h3><div class="textblock">丹霞：寻找五次或以上方程的解法是一个困扰了数学家们300多年的问题。历史上无数的数学家试图推导这些多项式方程求解算法，但无一例外都失败了。1824年，阿贝尔等人证明了五次及更高次的多项式方程没有一般的代数解法，即这样的方程不能由方程的系数经有限次四则运算和开方运算求解。<br  />
 1926年，苏家驹发表了一篇文章，声称自己发现了一个五次方程的求解算法。随后华罗庚在看了苏家驹的文章以后尝试继续推导六次方程的求解算法，这意味着他要尝试否定先前阿贝尔等人已经证实的“五次以上方程的解无法用系数表示”这一理论，但是当他看了阿贝尔的论文以后，认为其“条理精严，无懈可击”。随后他就转而开始尝试在苏家驹的论文中寻找漏洞，最终发表了他的成名之作《苏家驹之代数的五次方程式解法不能成立之理由》。<br  />
 阿贝尔定律已经证实五次以上方程的解无法使用系数组成的根式表示。也就是这些方程没有通用的求解算法。但是，这并不意味着它们完全没办法求解，此处使用杜兰德-肯纳算法求解这些方程。<br  />
<dl class="section user"><dt>参考文献：</dt><dd>[1] 苏家驹. 代数的五次方程式之解法[J]. 学艺, 1926.<br  />
 [2] 华罗庚. 苏家驹之代数的五次方程式解法不能成立之理由[J]. 科学, 1930.<br  />
 [3] Durand-Kerner method. Wikipedia. <a href="https://en.wikipedia.org/wiki/Durand-Kerner_method">https://en.wikipedia.org/wiki/Durand-Kerner_method</a></dd></dl>
<dl class="section note"><dt>注解</dt><dd>事实上，五次方程的解无法用根式表示的根本原因，是五次方程经过计算、消元后会变成特殊的六次方程，而那个特殊六次方程是否存在有理数根也是判断方程的解能否用根式表示的依据。<br  />
 而且六次方程用相同方法经过多次变换及消元后最终会得到10次或15次方程<br  />
 「所以别去对这些&gt;4次的一般形式硬消了，消不掉的。」 </dd></dl>
</div><h2 class="groupheader">类型定义说明</h2>
<a id="gaa363dcb20a57d00274808e3cf92306aa" name="gaa363dcb20a57d00274808e3cf92306aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa363dcb20a57d00274808e3cf92306aa">&#9670;&#160;</a></span>InputArray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gaa363dcb20a57d00274808e3cf92306aa">InputArray</a> = const std::vector&lt;float64&gt;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>输入系数数组类型 </p>

</div>
</div>
<a id="ga0cf635a645a56aeaca963fd40dc340e6" name="ga0cf635a645a56aeaca963fd40dc340e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cf635a645a56aeaca963fd40dc340e6">&#9670;&#160;</a></span>OutputArray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga0cf635a645a56aeaca963fd40dc340e6">OutputArray</a> = std::vector&lt;complex64&gt;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>输出解数组类型 </p>

</div>
</div>
<h2 class="groupheader">函数说明</h2>
<a id="ga1dbba6e1fd68071c003a0f150b67c835" name="ga1dbba6e1fd68071c003a0f150b67c835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dbba6e1fd68071c003a0f150b67c835">&#9670;&#160;</a></span>__Verify_Input_Output()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void __Verify_Input_Output </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gaa363dcb20a57d00274808e3cf92306aa">InputArray</a></td>          <td class="paramname"><span class="paramname"><em>Coeffs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga0cf635a645a56aeaca963fd40dc340e6">OutputArray</a></td>          <td class="paramname"><span class="paramname"><em>Roots</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64</td>          <td class="paramname"><span class="paramname"><em>Power</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>验证输入输出参数的有效性 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Coeffs</td><td>多项式系数数组(降幂排序) </td></tr>
    <tr><td class="paramname">Roots</td><td>解输出数组 </td></tr>
    <tr><td class="paramname">Power</td><td>多项式阶数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname">当输入无效时抛出异常</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9e4e4b1a7a18ee56d164319191c2b508" name="ga9e4e4b1a7a18ee56d164319191c2b508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e4e4b1a7a18ee56d164319191c2b508">&#9670;&#160;</a></span>SolveCubic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SolveCubic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gaa363dcb20a57d00274808e3cf92306aa">InputArray</a></td>          <td class="paramname"><span class="paramname"><em>Coeffs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga0cf635a645a56aeaca963fd40dc340e6">OutputArray</a></td>          <td class="paramname"><span class="paramname"><em>Roots</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64</td>          <td class="paramname"><span class="paramname"><em>Tolerence</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>求解一元三次方程 \(ax^3 + bx^2 + cx + d = 0\) (范盛金算法) </p>
<p>求解三次方程有两种算法，分别为卡尔丹公式和盛金公式。但是后来有人发现这两种算法都有问题：</p><ol type="1">
<li>卡尔丹公式没有认真对待复数解，且算法中含有大量复数开方。</li>
<li>范盛金的算法仍有部分缺陷需要更正</li>
</ol>
<p>对此2019年田红亮基于范盛金的成果进行了修正，下文采用此方法。</p>
<dl class="section note"><dt>注解</dt><dd>本算法的原作者范盛金于2018年9月6日晚在东莞离世，享年63岁</dd></dl>
<dl class="section user"><dt>参考文献</dt><dd>[1] 范盛金.一元三次方程的新求根公式与新判别法[J].海南师范学院学报(自然科学版),1989,2(2):91-98.<br  />
 [2] 田红亮.一元三次方程根的解法[J].湖北工程学院学报,2019,39(06):97-105.<br  />
 [3] 雪鳕.卡丹公式欺骗了五百年所有数学家[EB/OL].(2013-11-08)[2019-08-18]. <a href="http://blog.sina.com.cn/s/blog_6aa947af0101dy4f.html">http://blog.sina.com.cn/s/blog_6aa947af0101dy4f.html</a><br  />
 [4] 沈天珩.一元高次方程寻根记杂谈[EB/OL].(2020-02-03)[2025-05-09]. <a href="https://zhuanlan.zhihu.com/p/104832975">https://zhuanlan.zhihu.com/p/104832975</a><br  />
 [5] 毕式明,潘俊宇.“盛金公式”发明者、著名数学家范盛金辞世[EB/OL].南方Plus,(2018-09-08)[2025-05-09] <a href="https://www.sohu.com/a/252667814_100116740">https://www.sohu.com/a/252667814_100116740</a><br  />
</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Coeffs</td><td>系数数组 [a, b, c, d] </td></tr>
    <tr><td class="paramname">Roots</td><td>输出解数组(3个元素) </td></tr>
    <tr><td class="paramname">Tolerence</td><td>误差容限( \(10^{-Tolerence}\))，默认10 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>实际找到的解数量 </dd></dl>

</div>
</div>
<a id="ga3267fd69bd6b80868acf5e0a758972ec" name="ga3267fd69bd6b80868acf5e0a758972ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3267fd69bd6b80868acf5e0a758972ec">&#9670;&#160;</a></span>SolveLinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SolveLinear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gaa363dcb20a57d00274808e3cf92306aa">InputArray</a></td>          <td class="paramname"><span class="paramname"><em>Coeffs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga0cf635a645a56aeaca963fd40dc340e6">OutputArray</a></td>          <td class="paramname"><span class="paramname"><em>Roots</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>求解一元一次方程 \(ax + b = 0\) </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Coeffs</td><td>系数数组 [a, b] </td></tr>
    <tr><td class="paramname">Roots</td><td>输出解数组(1个元素) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>实际找到的解数量 </dd></dl>

</div>
</div>
<a id="ga7f1f3b4fba5ba76a9c268acb0cbdd7ba" name="ga7f1f3b4fba5ba76a9c268acb0cbdd7ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f1f3b4fba5ba76a9c268acb0cbdd7ba">&#9670;&#160;</a></span>SolvePoly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64 SolvePoly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gaa363dcb20a57d00274808e3cf92306aa">InputArray</a></td>          <td class="paramname"><span class="paramname"><em>Coeffs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga0cf635a645a56aeaca963fd40dc340e6">OutputArray</a></td>          <td class="paramname"><span class="paramname"><em>Roots</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/db7/struct_solve_poly_routine.html">SolvePolyRoutine</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Routine</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d6/d03/class_durand_kerner_solve_poly.html">DurandKernerSolvePoly</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>通用多项式求解函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Coeffs</td><td>多项式系数数组(降幂排序) </td></tr>
    <tr><td class="paramname">Roots</td><td>解输出数组 </td></tr>
    <tr><td class="paramname">Routine</td><td>求解算法实例(默认DurandKerner) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>迭代次数 </dd></dl>
<dl class="section see"><dt>参见</dt><dd><a href="https://en.wikipedia.org/wiki/Durand-Kerner_method">https://en.wikipedia.org/wiki/Durand-Kerner_method</a> </dd></dl>

</div>
</div>
<a id="gab22ac94f160103ac9e24bdee8852b776" name="gab22ac94f160103ac9e24bdee8852b776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab22ac94f160103ac9e24bdee8852b776">&#9670;&#160;</a></span>SolveQuadratic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SolveQuadratic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gaa363dcb20a57d00274808e3cf92306aa">InputArray</a></td>          <td class="paramname"><span class="paramname"><em>Coeffs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga0cf635a645a56aeaca963fd40dc340e6">OutputArray</a></td>          <td class="paramname"><span class="paramname"><em>Roots</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>求解一元二次方程 \(ax^2 + bx + c = 0\) </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Coeffs</td><td>系数数组 [a, b, c] </td></tr>
    <tr><td class="paramname">Roots</td><td>输出解数组(2个元素) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>实际找到的解数量 </dd></dl>

</div>
</div>
<a id="ga95ba492f7b6d313d1b3eafd733cb1a56" name="ga95ba492f7b6d313d1b3eafd733cb1a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95ba492f7b6d313d1b3eafd733cb1a56">&#9670;&#160;</a></span>SolveQuartic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SolveQuartic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gaa363dcb20a57d00274808e3cf92306aa">InputArray</a></td>          <td class="paramname"><span class="paramname"><em>Coeffs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga0cf635a645a56aeaca963fd40dc340e6">OutputArray</a></td>          <td class="paramname"><span class="paramname"><em>Roots</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64</td>          <td class="paramname"><span class="paramname"><em>Tolerence</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>求解一元四次方程 \(ax^4 + bx^3 + cx^2 + dx + e = 0\) (沈天珩算法) </p>
<h3><a class="anchor" id="一些碎碎念"></a>
一些碎碎念</h3>
<p>丹霞：历史上最先提出一般形式的四次方程的解法的是卡尔丹的学生费拉里。但是其公式复杂度极高，对此，沈天珩对公式进行了简化。同样的，相比费拉里算法，沈天珩算法中不会出现复数开方。<br  />
 沈天珩在知乎上另一篇四次方程求根公式证明文章下的评论说，他并没有对此公开发表过论文，仅仅只是在他本科辅修的毕设中提到过这个算法。对于计算机求解代码而言，不该出现根号时应尽量避免，万不得已出现根号最好避免复数开方，这些都是优势所在。毕竟像沈天珩算法这种除了求解以外还能判虚实判重根的算法太少了。 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Coeffs</td><td>系数数组 [a, b, c, d, e] </td></tr>
    <tr><td class="paramname">Roots</td><td>输出解数组(4个元素) </td></tr>
    <tr><td class="paramname">Tolerence</td><td>误差容限( \(10^{-Tolerence}\))，默认10 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>实际找到的解数量 </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.14.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <!-- <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li> -->
  </ul>
</div>
</body>
</html>
