<!-- HTML header for doxygen 1.14.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CSpaceEngine: 幂函数</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script type="text/javascript" src="../../darkmode_toggle.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CSpaceEngine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','搜索',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('df/d00/group___math_funcs_pow.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">函数</a>  </div>
  <div class="headertitle"><div class="title">幂函数<div class="ingroups"><a class="el" href="../../d9/ded/group___base.html">基本</a> &raquo; <a class="el" href="../../d4/d7d/group___math_funcs.html">数学函数</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>幂函数包含pow，sqrt，cbrt和yroot四个函数  
<a href="#details">更多...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
函数</h2></td></tr>
<tr class="memitem:gafc258d90abd7e349eb59fc72f7fbc92a" id="r_gafc258d90abd7e349eb59fc72f7fbc92a"><td class="memItemLeft" align="right" valign="top">float64 __cdecl&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafc258d90abd7e349eb59fc72f7fbc92a">pow</a> (float64 _X, float64 _Power)</td></tr>
<tr class="memdesc:gafc258d90abd7e349eb59fc72f7fbc92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">计算幂函数（x^y）  <br /></td></tr>
<tr class="separator:gafc258d90abd7e349eb59fc72f7fbc92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f8f8860a95bf9d42948ffb961c73cc1" id="r_ga0f8f8860a95bf9d42948ffb961c73cc1"><td class="memItemLeft" align="right" valign="top">complex64 __cdecl&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0f8f8860a95bf9d42948ffb961c73cc1">powc</a> (complex64 _X, complex64 _Power, int64 K_OFFSET=0)</td></tr>
<tr class="memdesc:ga0f8f8860a95bf9d42948ffb961c73cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">计算复数的幂函数（z^w）  <br /></td></tr>
<tr class="separator:ga0f8f8860a95bf9d42948ffb961c73cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c3c2a472a16d65146a0a2f245769b47" id="r_ga7c3c2a472a16d65146a0a2f245769b47"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:ga7c3c2a472a16d65146a0a2f245769b47"><td class="memTemplItemLeft" align="right" valign="top">fvec&lt; N &gt; __cdecl&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga7c3c2a472a16d65146a0a2f245769b47">pow</a> (fvec&lt; N &gt; _X, float64 _Power)</td></tr>
<tr class="memdesc:ga7c3c2a472a16d65146a0a2f245769b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">计算向量各元素的标量指数幂  <br /></td></tr>
<tr class="separator:ga7c3c2a472a16d65146a0a2f245769b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga306f8c96764d3a59142e63f006c00a13" id="r_ga306f8c96764d3a59142e63f006c00a13"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:ga306f8c96764d3a59142e63f006c00a13"><td class="memTemplItemLeft" align="right" valign="top">fvec&lt; N &gt; __cdecl&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga306f8c96764d3a59142e63f006c00a13">pow</a> (fvec&lt; N &gt; _X, fvec&lt; N &gt; _Power)</td></tr>
<tr class="memdesc:ga306f8c96764d3a59142e63f006c00a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">计算向量各元素的向量指数幂  <br /></td></tr>
<tr class="separator:ga306f8c96764d3a59142e63f006c00a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16779c07b8066a2f154744d03eed1e73" id="r_ga16779c07b8066a2f154744d03eed1e73"><td class="memTemplParams" colspan="2">template&lt;std::size_t _Size&gt; </td></tr>
<tr class="memitem:ga16779c07b8066a2f154744d03eed1e73"><td class="memTemplItemLeft" align="right" valign="top">matrix&lt; _Size, _Size &gt; __cdecl&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga16779c07b8066a2f154744d03eed1e73">pow</a> (matrix&lt; _Size, _Size &gt; _A, uint64 _Power)</td></tr>
<tr class="memdesc:ga16779c07b8066a2f154744d03eed1e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">计算矩阵的整数次幂  <br /></td></tr>
<tr class="separator:ga16779c07b8066a2f154744d03eed1e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga620a9b7af7ede23efc704b31d3302a98" id="r_ga620a9b7af7ede23efc704b31d3302a98"><td class="memItemLeft" align="right" valign="top">float64 __cdecl&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga620a9b7af7ede23efc704b31d3302a98">sqrt</a> (float64 _X)</td></tr>
<tr class="memdesc:ga620a9b7af7ede23efc704b31d3302a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">计算平方根（√x）  <br /></td></tr>
<tr class="separator:ga620a9b7af7ede23efc704b31d3302a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a9eb9588318ba54a783ef5a405ede0c" id="r_ga3a9eb9588318ba54a783ef5a405ede0c"><td class="memItemLeft" align="right" valign="top">std::array&lt; complex64, 2 &gt; __cdecl&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3a9eb9588318ba54a783ef5a405ede0c">sqrtc</a> (complex64 _X)</td></tr>
<tr class="memdesc:ga3a9eb9588318ba54a783ef5a405ede0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">计算复数的平方根  <br /></td></tr>
<tr class="separator:ga3a9eb9588318ba54a783ef5a405ede0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8929fcda428dc4db72382cdd0034db68" id="r_ga8929fcda428dc4db72382cdd0034db68"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:ga8929fcda428dc4db72382cdd0034db68"><td class="memTemplItemLeft" align="right" valign="top">fvec&lt; N &gt; __cdecl&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga8929fcda428dc4db72382cdd0034db68">sqrt</a> (fvec&lt; N &gt; _X)</td></tr>
<tr class="memdesc:ga8929fcda428dc4db72382cdd0034db68"><td class="mdescLeft">&#160;</td><td class="mdescRight">计算向量各元素的平方根  <br /></td></tr>
<tr class="separator:ga8929fcda428dc4db72382cdd0034db68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b16525313c59d09dd105e1f06c712d9" id="r_ga4b16525313c59d09dd105e1f06c712d9"><td class="memItemLeft" align="right" valign="top">float64 __cdecl&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4b16525313c59d09dd105e1f06c712d9">inversesqrt</a> (float64 _X)</td></tr>
<tr class="memdesc:ga4b16525313c59d09dd105e1f06c712d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">计算平方根倒数（1/√x）  <br /></td></tr>
<tr class="separator:ga4b16525313c59d09dd105e1f06c712d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67246ccc462e1c1cc1311acc9405beaa" id="r_ga67246ccc462e1c1cc1311acc9405beaa"><td class="memItemLeft" align="right" valign="top">std::array&lt; complex64, 2 &gt; __cdecl&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga67246ccc462e1c1cc1311acc9405beaa">inversesqrtc</a> (complex64 _X)</td></tr>
<tr class="memdesc:ga67246ccc462e1c1cc1311acc9405beaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">计算复数的平方根倒数  <br /></td></tr>
<tr class="separator:ga67246ccc462e1c1cc1311acc9405beaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54c32040fe95b6f802245358d24dec5f" id="r_ga54c32040fe95b6f802245358d24dec5f"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:ga54c32040fe95b6f802245358d24dec5f"><td class="memTemplItemLeft" align="right" valign="top">fvec&lt; N &gt; __cdecl&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga54c32040fe95b6f802245358d24dec5f">inversesqrt</a> (fvec&lt; N &gt; _X)</td></tr>
<tr class="memdesc:ga54c32040fe95b6f802245358d24dec5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">计算向量各元素的平方根倒数  <br /></td></tr>
<tr class="separator:ga54c32040fe95b6f802245358d24dec5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac69570caaad12c3891b5aaab121f812" id="r_gaac69570caaad12c3891b5aaab121f812"><td class="memItemLeft" align="right" valign="top">float64 __cdecl&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaac69570caaad12c3891b5aaab121f812">cbrt</a> (float64 _X)</td></tr>
<tr class="memdesc:gaac69570caaad12c3891b5aaab121f812"><td class="mdescLeft">&#160;</td><td class="mdescRight">计算立方根（³√x）  <br /></td></tr>
<tr class="separator:gaac69570caaad12c3891b5aaab121f812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1f1555c911c227d109b4a7dcaee7d04" id="r_gaf1f1555c911c227d109b4a7dcaee7d04"><td class="memItemLeft" align="right" valign="top">std::array&lt; complex64, 3 &gt; __cdecl&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf1f1555c911c227d109b4a7dcaee7d04">cbrtc</a> (complex64 _X)</td></tr>
<tr class="memdesc:gaf1f1555c911c227d109b4a7dcaee7d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">计算复数的立方根  <br /></td></tr>
<tr class="separator:gaf1f1555c911c227d109b4a7dcaee7d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae41264b3e45930cf39f533e9ec98d2cd" id="r_gae41264b3e45930cf39f533e9ec98d2cd"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:gae41264b3e45930cf39f533e9ec98d2cd"><td class="memTemplItemLeft" align="right" valign="top">fvec&lt; N &gt; __cdecl&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gae41264b3e45930cf39f533e9ec98d2cd">cbrt</a> (fvec&lt; N &gt; _X)</td></tr>
<tr class="memdesc:gae41264b3e45930cf39f533e9ec98d2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">计算向量各元素的立方根  <br /></td></tr>
<tr class="separator:gae41264b3e45930cf39f533e9ec98d2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd80ab4931b4662c0da0b38dc57525b2" id="r_gacd80ab4931b4662c0da0b38dc57525b2"><td class="memItemLeft" align="right" valign="top">float64 __cdecl&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacd80ab4931b4662c0da0b38dc57525b2">yroot</a> (float64 _X, float64 _Expo)</td></tr>
<tr class="memdesc:gacd80ab4931b4662c0da0b38dc57525b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">计算任意次方根（ʸ√x）  <br /></td></tr>
<tr class="separator:gacd80ab4931b4662c0da0b38dc57525b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7042401014af7fec0717ef674695921f" id="r_ga7042401014af7fec0717ef674695921f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; complex64 &gt; __cdecl&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7042401014af7fec0717ef674695921f">yrootc</a> (complex64 _X, complex64 _Expo, int64 K_OFFSET=0)</td></tr>
<tr class="memdesc:ga7042401014af7fec0717ef674695921f"><td class="mdescLeft">&#160;</td><td class="mdescRight">计算复数的任意次方根  <br /></td></tr>
<tr class="separator:ga7042401014af7fec0717ef674695921f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdb4903d2360c421a7a71d9897a286a4" id="r_gafdb4903d2360c421a7a71d9897a286a4"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:gafdb4903d2360c421a7a71d9897a286a4"><td class="memTemplItemLeft" align="right" valign="top">fvec&lt; N &gt; __cdecl&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gafdb4903d2360c421a7a71d9897a286a4">yroot</a> (fvec&lt; N &gt; _X, float64 _Expo)</td></tr>
<tr class="memdesc:gafdb4903d2360c421a7a71d9897a286a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">计算向量各元素的标量指数方根  <br /></td></tr>
<tr class="separator:gafdb4903d2360c421a7a71d9897a286a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga359f10f1db3541e89089f776bbc46343" id="r_ga359f10f1db3541e89089f776bbc46343"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:ga359f10f1db3541e89089f776bbc46343"><td class="memTemplItemLeft" align="right" valign="top">fvec&lt; N &gt; __cdecl&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga359f10f1db3541e89089f776bbc46343">yroot</a> (fvec&lt; N &gt; _X, fvec&lt; N &gt; _Expo)</td></tr>
<tr class="memdesc:ga359f10f1db3541e89089f776bbc46343"><td class="mdescLeft">&#160;</td><td class="mdescRight">计算向量各元素的向量指数方根  <br /></td></tr>
<tr class="separator:ga359f10f1db3541e89089f776bbc46343"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<p>幂函数包含pow，sqrt，cbrt和yroot四个函数 </p>
<p><b>以下内容为AI智能解析，仅供参考</b></p>
<h3><a class="anchor" id="pow-函数原理解析"></a>
<code>pow</code> 函数原理解析</h3>
<p><code>pow(x, y)</code> 函数计算 <code>x</code> 的 <code>y</code> 次幂（ \(x^y\)）。其核心原理是将幂运算转化为指数和对数的组合：</p>
<p class="formulaDsp">
\[
   x^y = e^{y \cdot \ln(x)}
   \]
</p>
<h4><a class="anchor" id="关键步骤"></a>
关键步骤：</h4>
<ol type="1">
<li><b>特殊输入处理</b> ：<ul>
<li>检查 <code>x</code> 和 <code>y</code> 是否为 <code>0</code>、<code>Inf</code> 或 <code>NaN</code>，按 IEEE 754 规则返回结果。</li>
<li>处理负数底数 <code>x &lt; 0</code>：<ul>
<li>若 <code>y</code> 不是整数，返回 <code>NaN</code>（如 \((-2)^{0.5}\)）。</li>
<li>若 <code>y</code> 是整数，根据奇偶性确定符号（奇数为负，偶数为正）。</li>
</ul>
</li>
</ul>
</li>
<li><b>计算自然对数</b> ：<ul>
<li><b>分解 <code>x</code></b> ：将 <code>x</code> 表示为 \(x = 2^k \cdot z\)，其中 \(z \in [0.8, 1.6)\)。</li>
<li><b>查表近似</b> ：使用预计算表 <code>__Pow64f_ln_table</code> 获取 <code>ln(z)</code> 的高精度值：<ul>
<li><code>invc</code>：中心点倒数 \(1/c\)</li>
<li><code>lnc</code>： \(\ln(c)\) 的主部</li>
<li><code>lnctail</code>： \(\ln(c)\) 的尾部（补偿精度）</li>
</ul>
</li>
<li><b>泰勒展开</b> ：计算 \(\ln(z/c) = \text{poly}(z/c - 1)\)，多项式系数优化了精度。</li>
</ul>
</li>
<li><b>计算 y * ln(x)</b> ：<ul>
<li>将 <code>y</code> 和 \(\ln(x)\) 拆分为高位和低位部分，减少浮点误差：   <p class="formulaDsp">
\[
       y \cdot \ln(x) = (y_{\text{hi}} + y_{\text{lo}}) \cdot (\ln_{\text{hi}} + \ln_{\text{lo}})
       \]
</p>
</li>
<li>分别计算乘积并累加，保留高精度。</li>
</ul>
</li>
<li><b>计算指数e^sum</b> ：<ul>
<li><b>分解指数</b> ：将输入 \(s = y \cdot \ln(x)\) 表示为：   <p class="formulaDsp">
\[
       s = \frac{k \cdot \ln 2}{N} + r, \quad N = 128
       \]
</p>
</li>
<li><b>查表</b> ：使用 <code>__Exp64f_table</code> 获取 \(2^{k/N}\) 的近似值 <code>scale</code> 和 <code>tail</code>。</li>
<li><b>泰勒展开</b> ：计算 \(e^r \approx 1 + r + \frac{r^2}{2!} + \cdots\)。</li>
<li><b>组合结果</b> ：   <p class="formulaDsp">
\[
       e^s \approx \text{scale} \cdot (1 + (\text{tail} + (e^r - 1)))
       \]
</p>
</li>
</ul>
</li>
<li><b>处理边界条件</b> ：<ul>
<li>检测中间结果是否可能溢出/下溢，调整缩放因子。</li>
<li>次正规数（Subnormal）结果特殊处理，避免双重舍入误差。</li>
</ul>
</li>
</ol>
<h4><a class="anchor" id="精度优化技术-"></a>
精度优化技术 ：</h4>
<ul>
<li><b>高位低位拆分</b> ：关键计算步骤将浮点数拆分为高位和低位，减少舍入误差。</li>
<li><b>补偿精度</b> ：对数和指数表存储主部和尾部，补偿浮点精度损失。</li>
<li><b>定制多项式</b> ：泰勒级数系数针对浮点运算优化，平衡精度和性能。</li>
</ul>
<h4><a class="anchor" id="特殊值处理示例"></a>
特殊值处理示例：</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><code>x</code>   </th><th class="markdownTableHeadNone"><code>y</code>   </th><th class="markdownTableHeadNone">结果    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>NaN</code>   </td><td class="markdownTableBodyNone">任意   </td><td class="markdownTableBodyNone"><code>NaN</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>1</code>   </td><td class="markdownTableBodyNone"><code>NaN</code>   </td><td class="markdownTableBodyNone"><code>NaN</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>负数</code>   </td><td class="markdownTableBodyNone">非整数   </td><td class="markdownTableBodyNone"><code>NaN</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>0</code>   </td><td class="markdownTableBodyNone">负数   </td><td class="markdownTableBodyNone"><code>Inf</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>+Inf</code>   </td><td class="markdownTableBodyNone"><code>&gt;0</code>   </td><td class="markdownTableBodyNone"><code>+Inf</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>+Inf</code>   </td><td class="markdownTableBodyNone"><code>&lt;0</code>   </td><td class="markdownTableBodyNone"><code>0</code>   </td></tr>
</table>
<h3><a class="anchor" id="总结-3"></a>
总结</h3>
<p>该 <code>pow</code> 实现通过转化为对数和指数运算，结合查表法与多项式近似，在保证 IEEE 754 精度的同时高效计算幂函数。特殊输入处理严谨，并采用多种技术减少浮点误差，适用于高性能数学库。</p>
<h3><a class="anchor" id="一些碎碎念"></a>
一些碎碎念</h3>
<p>丹霞：早期版本的glibc中数学函数使用的是IBM设计的函数，其中一些函数在输入特定值的时候会产生高到离谱的延迟，一个典型的例子就是这个pow函数。根据网络上的一些反馈，此函数在输入(x -&gt; 1, 1.5)的时候就会出现一定的延迟，且当x越接近1延迟越高，而输入x = 1.000000000000002时，延迟高达~777毫秒，这显然是无法接受的。另外据说IBM设计的exp函数在输入[-0.00000000033301145180213807, -0.00000000033301145180369239]以内的值时也会产生比正常情况高上百倍的延迟。所以目前版本的glibc除平方根和弧度三角函数外已经换用了自行设计的数学函数。<br  />
 参考：</p><ol type="1">
<li>菲利普·马尔基诺写给glibc客服的信：https://sourceware.org/legacy-ml/libc-help/2009-01/msg00003.html</li>
<li>莱昂内尔·柴兰与Debian客服奥雷利安·雅诺的对话：https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=585430</li>
<li>阿什瓦尼·巴特与安德鲁·哈里的对话：https://gcc.gnu.org/legacy-ml/gcc-help/2006-05/msg00185.html，https://gcc.gnu.org/legacy-ml/gcc-help/2006-05/msg00189.html</li>
<li>杰森·萨默斯的测试与看法：https://entropymine.com/imageworsener/slowpow/</li>
<li>IBM当年独领风骚的数学函数库代码(大奋警告！！！)：https://github.com/dreal-deps/mathlib （IBM：屮艸芔茻！）</li>
</ol>
<hr  />
<p> <b>以下内容为AI智能解析，仅供参考</b></p>
<h3><a class="anchor" id="sqrt-函数原理分析ibm-ultimate-算法"></a>
<code>sqrt</code> 函数原理分析（IBM Ultimate 算法）</h3>
<p><code>sqrt(x)</code> 函数实现了高精度双精度浮点数平方根计算，以下是其核心原理和步骤：</p>
<h4><a class="anchor" id="autotoc_md1-预处理输入值"></a>
<b>1. 预处理输入值</b></h4>
<ul>
<li><b>提取指数和尾数</b> <br  />
 通过 <code>a.parts.msw</code> 获取浮点数的高32位（包含指数和部分尾数）。</li>
<li><b>规格化到 [0.5, 1) 区间</b> <br  />
 修改指数位为 <code>0x3fe00000</code>，使输入值 \(a\) 落在 \([0.5, 1)\) 范围内： <div class="fragment"><div class="line">a.parts.msw = (k &amp; 0x001fffff) | 0x3fe00000;  <span class="comment">// k 是原始高32位</span></div>
</div><!-- fragment --></li>
</ul>
<h4><a class="anchor" id="autotoc_md2-初始近似值查找"></a>
<b>2. 初始近似值查找</b></h4>
<ul>
<li><b>查表获取 1/sqrt(a)</b> <br  />
 使用尾数的高7位作为索引，从预计算表 <code>__IBM_inroot_table</code> 中获取初始近似值 \(t\)： <div class="fragment"><div class="line">t = __IBM_inroot_table[(k &amp; 0x001fffff) &gt;&gt; 14];  <span class="comment">// 128项查找表</span></div>
</div><!-- fragment --></li>
</ul>
<h4><a class="anchor" id="autotoc_md3-泰勒级数迭代优化"></a>
<b>3. 泰勒级数迭代优化</b></h4>
<ul>
<li><b>计算残差 y</b> <br  />
 \(y = 1 - t^2 \cdot a\)，衡量当前近似值的误差。</li>
<li><b>多项式修正 t</b> <br  />
 使用泰勒级数前4项优化 \(t\)（系数为 <code>rt0</code>-<code>rt3</code>）： <div class="fragment"><div class="line">t = t * (rt0 + y * (rt1 + y * (rt2 + y * rt3));</div>
</div><!-- fragment --></li>
</ul>
<h4><a class="anchor" id="autotoc_md4-结果重构与修正"></a>
<b>4. 结果重构与修正</b></h4>
<ul>
<li><b>指数补偿 c</b> <br  />
 恢复原始输入的指数缩放： <div class="fragment"><div class="line">c.parts.msw = 0x20000000 + ((k &amp; 0x7fe00000) &gt;&gt; 1);  <span class="comment">// 指数减半</span></div>
</div><!-- fragment --></li>
<li><b>计算初步平方根 y = t * a</b> <br  />
</li>
<li><b>高位提取与误差修正</b> <br  />
 用 <code>big = 134217728.0</code> 分离高低位，计算修正量 <code>del</code>： <div class="fragment"><div class="line">hy = (y + big) - big;  <span class="comment">// 高位部分</span></div>
<div class="line">del = 0.5 * t * ((a - hy*hy) - (y - hy)*(y + hy)); <span class="comment">// 误差修正</span></div>
<div class="line">res = y + del;  <span class="comment">// 修正后的结果</span></div>
</div><!-- fragment --></li>
</ul>
<h4><a class="anchor" id="autotoc_md5-精确舍入处理"></a>
<b>5. 精确舍入处理</b></h4>
<ul>
<li><b>二次修正（必要时）</b> <br  />
 若一次修正未收敛，通过精确乘法 <code>EMULV</code> 比较候选值： <div class="fragment"><div class="line">EMULV(res, res1, z, zz);  <span class="comment">// 计算 z + zz = res * res1</span></div>
<div class="line">res = ((z + zz - a) &lt; 0) ? max(res, res1) : min(res, res1);</div>
</div><!-- fragment --></li>
<li><b>舍入模式调整</b> <br  />
 检查 \(x / \text{res} == \text{res}\) 判断是否精确，否则微调结果： <div class="fragment"><div class="line"><span class="keywordflow">if</span> (x / res != res) </div>
<div class="line">    res = (res - 0x1p-1022) * c;  <span class="comment">// 处理非精确舍入</span></div>
</div><!-- fragment --></li>
</ul>
<h4><a class="anchor" id="autotoc_md6-特殊值处理"></a>
<b>6. 特殊值处理</b></h4>
<ul>
<li><b>负数</b> ：返回 <code>NaN</code>（<code>S_NAN_DOUBLE</code>）。</li>
<li><b>零</b> ：返回原值（保持符号）。</li>
<li><b>无穷/NaN</b> ：返回 \(x \cdot x + x\)（保留 NaN 或返回 +∞）。</li>
<li><b>次正规数</b> ：缩放至正规范围后递归计算： <div class="fragment"><div class="line"><span class="keywordflow">return</span> 0x1p-256 * __IBM_SQRT64F(x * 0x1p512);  <span class="comment">// 缩放因子 2^512 / 2^256</span></div>
</div><!-- fragment --></li>
</ul>
<h3><a class="anchor" id="关键优化技术"></a>
<b>关键优化技术</b></h3>
<ol type="1">
<li><b>查找表加速</b> <br  />
 128项预计算表提供高精度初始值。</li>
<li><b>多项式逼近</b> <br  />
 泰勒级数快速收敛到高精度解。</li>
<li><b>高低位分离法</b> <br  />
 用 <code>big</code> 常量分离浮点数高低位，减少舍入误差。</li>
<li><b>精确乘积累加</b> <br  />
 <code>EMULV</code> 函数通过 Dekker 算法实现双精度乘积的精确计算。</li>
</ol>
<h3><a class="anchor" id="复杂度"></a>
<b>复杂度</b></h3>
<ul>
<li><b>时间复杂度</b> ：常数时间（无循环，仅固定步骤）。</li>
<li><b>空间复杂度</b> ：128项查找表（约 1KB）。</li>
</ul>
<p>此算法通过结合查表、多项式逼近和误差补偿，实现了 IEEE 754 双精度要求的正确舍入（round-to-nearest）。</p>
<hr  />
<p><b>以下内容为AI智能解析，仅供参考</b></p>
<h3><a class="anchor" id="cbrt-函数原理分析"></a>
<code>cbrt</code> 函数原理分析</h3>
<h4><a class="anchor" id="autotoc_md1-核心算法浮点数立方根计算"></a>
1. <b>核心算法：浮点数立方根计算</b></h4>
<p>双精度浮点数（<code>float64</code>）的立方根计算步骤如下：</p>
<ol type="1">
<li><b>规范化输入</b> ：<ul>
<li>使用 <code>frexp(fabs(x), &amp;xe)</code> 将输入 <code>x</code> 分解为尾数 <code>xm</code>（范围 <code>[0.5, 1)</code>）和指数 <code>xe</code>：   <p class="formulaDsp">
\[
       x = \text{sign}(x) \times xm \times 2^{xe}
       \]
</p>
</li>
</ul>
</li>
<li><b>特殊值处理</b> ：<ul>
<li>若 <code>x</code> 为 <code>0</code>、<code>Inf</code> 或 <code>NaN</code>，直接返回原值。</li>
</ul>
</li>
<li><b>多项式近似初始值</b> ：<ul>
<li>在区间 <code>[0.5, 1)</code> 上，使用 <b>7次多项式</b> 计算初始近似值 <code>u</code>：   <p class="formulaDsp">
\[
       u = \sum_{i=0}^{6} a_i \cdot xm^i
       \]
</p>
 系数为： <div class="fragment"><div class="line">a0 = 0.354895765043919860</div>
<div class="line">a1 = 1.50819193781584896</div>
<div class="line">a2 = -2.11499494167371287</div>
<div class="line">a3 = 2.44693122563534430</div>
<div class="line">a4 = -1.83469277483613086</div>
<div class="line">a5 = 0.784932344976639262</div>
<div class="line">a6 = -0.145263899385486377</div>
</div><!-- fragment --></li>
</ul>
</li>
<li><b>哈雷迭代优化</b> ：<ul>
<li>通过 <b>一次哈雷迭代</b> 提升精度：      <p class="formulaDsp">
\[
       \begin{align*}
       t2 &amp;= u^3 \\
       ym &amp;= u \times \frac{t2 + 2 \times xm}{2 \times t2 + xm}
       \end{align*}
       \]
</p>
 哈雷迭代针对方程 \( f(u) = u^3 - xm = 0 \) 设计，收敛速度快。</li>
</ul>
</li>
<li><b>指数修正</b> ：<ul>
<li>分解指数： \( xe = 3q + r \)（ \( r \in \{0, 1, 2\} \))</li>
<li>查表 <code>factor[5]</code> 补偿余数部分 \( 2^{r/3} \)： <div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> __Float64 factor[5] = {</div>
<div class="line">    0.62996052494743658, <span class="comment">// 2^{-2/3}</span></div>
<div class="line">    0.79370052598409974, <span class="comment">// 2^{-1/3}</span></div>
<div class="line">    1.0,                 <span class="comment">// 2^{0/3}</span></div>
<div class="line">    1.25992104989487316, <span class="comment">// 2^{1/3}</span></div>
<div class="line">    1.58740105196819947  <span class="comment">// 2^{2/3}</span></div>
<div class="line">};</div>
</div><!-- fragment --></li>
<li>最终结果：   <p class="formulaDsp">
\[
       \text{cbrt}(x) = \text{sign}(x) \times ym \times \text{factor}[2 + r] \times 2^{q}
       \]
</p>
 其中 \( q = \text{floor}(xe / 3) \)，通过 <code>ldexp</code> 实现 \( 2^q \) 的缩放。</li>
</ul>
</li>
</ol>
<h4><a class="anchor" id="autotoc_md2-复数立方根计算"></a>
2. <b>复数立方根计算</b></h4>
<p><code>cbrtc</code> 函数计算复数立方根（3个解）：</p><ol type="1">
<li>极坐标转换：      <p class="formulaDsp">
\[
   \begin{align*}
   r &amp;= |x| \\
   \theta &amp;= \text{atan2}(\Im(x), \Re(x))
   \end{align*}
   \]
</p>
</li>
<li>计算模的立方根： \( ri = \text{cbrt}(r) \)</li>
<li>生成三个解：     <p class="formulaDsp">
\[
   \begin{align*}
   z_k &amp;= ri \times \exp\left(i \frac{\theta + 2k\pi}{3}\right), \quad k = 0, 1, 2
   \end{align*}
   \]
</p>
 使用欧拉公式 \( \exp(i\phi) = \cos\phi + i\sin\phi \) 计算。</li>
</ol>
<h4><a class="anchor" id="autotoc_md3-关键优化点"></a>
3. <b>关键优化点</b></h4>
<ul>
<li><b>尾数区间压缩</b> ：<code>xm ∈ [0.5, 1)</code> 保证多项式近似高效。</li>
<li><b>快速迭代</b> ：一次哈雷迭代平衡精度与效率。</li>
<li><b>指数分解</b> ：查表法避免实时计算 \( 2^{r/3} \)。</li>
<li><b>符号处理</b> ：全程使用 <code>fabs(x)</code>，最后恢复符号。</li>
</ul>
<h4><a class="anchor" id="autotoc_md4-潜在缺陷"></a>
4. <b>潜在缺陷</b></h4>
<ul>
<li><b>负指数处理</b> ： <br  />
 当 \( xe &lt; 0 \) 时，<code>xe % 3</code> 可能产生负余数（如 \( xe = -1 \rightarrow r = -1 \)），导致访问 <code>factor[1] = 2^{-1/3}</code>（正确应为 \( 2^{2/3} \)）。 <br  />
 <b>修复建议</b> ：调整余数为非负： <div class="fragment"><div class="line"><span class="keywordtype">int</span> r = xe % 3;</div>
<div class="line"><span class="keywordflow">if</span> (r &lt; 0) r += 3;  <span class="comment">// 确保 r ∈ {0,1,2}</span></div>
</div><!-- fragment --></li>
</ul>
<h4><a class="anchor" id="autotoc_md5-数学依据"></a>
5. <b>数学依据</b></h4>
<ul>
<li><b>哈雷迭代公式</b> ： <br  />
 对 \( f(u) = u^3 - xm \)，迭代式为：   <p class="formulaDsp">
\[
   u_{n+1} = u_n - \frac{2f(u_n)f&#39;(u_n)}{2[f&#39;(u_n)]^2 - f(u_n)f&#39;&#39;(u_n)} = u_n \frac{u_n^3 + 2xm}{2u_n^3 + xm}
   \]
</p>
</li>
<li><b>指数分解</b> ： <br  />
   <p class="formulaDsp">
\[
   x = \pm \ xm \times 2^{xe} \implies \sqrt[3]{x} = \pm \ \sqrt[3]{xm} \times 2^{xe/3}
   \]
</p>
 其中 \( xe/3 = q + r/3 \)（ \( q \in \mathbb{Z}, r \in \{0,1,2\} \)）。</li>
</ul>
<h3><a class="anchor" id="总结-4"></a>
总结</h3>
<ul>
<li><b>实立方根</b> ：结合多项式逼近与哈雷迭代，通过指数分解和查表优化性能。</li>
<li><b>复立方根</b> ：基于极坐标和欧拉公式生成三个解。</li>
<li><b>工业级实现</b> ：代码源自 GNU C 库，兼顾精度与速度，适用于科学计算场景。 </li>
</ul>
<h2 class="groupheader">函数说明</h2>
<a id="gaac69570caaad12c3891b5aaab121f812" name="gaac69570caaad12c3891b5aaab121f812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac69570caaad12c3891b5aaab121f812">&#9670;&#160;</a></span>cbrt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float64 __cdecl cbrt </td>
          <td>(</td>
          <td class="paramtype">float64</td>          <td class="paramname"><span class="paramname"><em>_X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>计算立方根（³√x） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_X</td><td>被开方数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>_X 的立方根 </dd></dl>

</div>
</div>
<a id="gae41264b3e45930cf39f533e9ec98d2cd" name="gae41264b3e45930cf39f533e9ec98d2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae41264b3e45930cf39f533e9ec98d2cd">&#9670;&#160;</a></span>cbrt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">fvec&lt; N &gt; __cdecl cbrt </td>
          <td>(</td>
          <td class="paramtype">fvec&lt; N &gt;</td>          <td class="paramname"><span class="paramname"><em>_X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>计算向量各元素的立方根 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>向量维度 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_X</td><td>输入向量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>各元素立方根结果向量 </dd></dl>

</div>
</div>
<a id="gaf1f1555c911c227d109b4a7dcaee7d04" name="gaf1f1555c911c227d109b4a7dcaee7d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1f1555c911c227d109b4a7dcaee7d04">&#9670;&#160;</a></span>cbrtc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; complex64, 3 &gt; __cdecl cbrtc </td>
          <td>(</td>
          <td class="paramtype">complex64</td>          <td class="paramname"><span class="paramname"><em>_X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>计算复数的立方根 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_X</td><td>复数被开方数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含三个立方根的数组 </dd></dl>

</div>
</div>
<a id="ga4b16525313c59d09dd105e1f06c712d9" name="ga4b16525313c59d09dd105e1f06c712d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b16525313c59d09dd105e1f06c712d9">&#9670;&#160;</a></span>inversesqrt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float64 __cdecl inversesqrt </td>
          <td>(</td>
          <td class="paramtype">float64</td>          <td class="paramname"><span class="paramname"><em>_X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>计算平方根倒数（1/√x） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_X</td><td>被开方数（必须 &gt; 0） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>_X 的平方根倒数 </dd></dl>

</div>
</div>
<a id="ga54c32040fe95b6f802245358d24dec5f" name="ga54c32040fe95b6f802245358d24dec5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54c32040fe95b6f802245358d24dec5f">&#9670;&#160;</a></span>inversesqrt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">fvec&lt; N &gt; __cdecl inversesqrt </td>
          <td>(</td>
          <td class="paramtype">fvec&lt; N &gt;</td>          <td class="paramname"><span class="paramname"><em>_X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>计算向量各元素的平方根倒数 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>向量维度 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_X</td><td>输入向量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>各元素平方根倒数结果向量 </dd></dl>

</div>
</div>
<a id="ga67246ccc462e1c1cc1311acc9405beaa" name="ga67246ccc462e1c1cc1311acc9405beaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67246ccc462e1c1cc1311acc9405beaa">&#9670;&#160;</a></span>inversesqrtc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; complex64, 2 &gt; __cdecl inversesqrtc </td>
          <td>(</td>
          <td class="paramtype">complex64</td>          <td class="paramname"><span class="paramname"><em>_X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>计算复数的平方根倒数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_X</td><td>复数被开方数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含两个平方根倒数的数组 </dd></dl>

</div>
</div>
<a id="gafc258d90abd7e349eb59fc72f7fbc92a" name="gafc258d90abd7e349eb59fc72f7fbc92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc258d90abd7e349eb59fc72f7fbc92a">&#9670;&#160;</a></span>pow() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float64 __cdecl pow </td>
          <td>(</td>
          <td class="paramtype">float64</td>          <td class="paramname"><span class="paramname"><em>_X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64</td>          <td class="paramname"><span class="paramname"><em>_Power</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>计算幂函数（x^y） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_X</td><td>底数值 </td></tr>
    <tr><td class="paramname">_Power</td><td>指数值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>_X 的 _Power 次幂 </dd></dl>

</div>
</div>
<a id="ga7c3c2a472a16d65146a0a2f245769b47" name="ga7c3c2a472a16d65146a0a2f245769b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c3c2a472a16d65146a0a2f245769b47">&#9670;&#160;</a></span>pow() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">fvec&lt; N &gt; __cdecl pow </td>
          <td>(</td>
          <td class="paramtype">fvec&lt; N &gt;</td>          <td class="paramname"><span class="paramname"><em>_X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64</td>          <td class="paramname"><span class="paramname"><em>_Power</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>计算向量各元素的标量指数幂 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>向量维度 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_X</td><td>底数向量 </td></tr>
    <tr><td class="paramname">_Power</td><td>指数值（标量） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>各元素幂结果向量 </dd></dl>

</div>
</div>
<a id="ga306f8c96764d3a59142e63f006c00a13" name="ga306f8c96764d3a59142e63f006c00a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga306f8c96764d3a59142e63f006c00a13">&#9670;&#160;</a></span>pow() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">fvec&lt; N &gt; __cdecl pow </td>
          <td>(</td>
          <td class="paramtype">fvec&lt; N &gt;</td>          <td class="paramname"><span class="paramname"><em>_X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fvec&lt; N &gt;</td>          <td class="paramname"><span class="paramname"><em>_Power</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>计算向量各元素的向量指数幂 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>向量维度 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_X</td><td>底数向量 </td></tr>
    <tr><td class="paramname">_Power</td><td>指数向量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>各元素幂结果向量 </dd></dl>

</div>
</div>
<a id="ga16779c07b8066a2f154744d03eed1e73" name="ga16779c07b8066a2f154744d03eed1e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16779c07b8066a2f154744d03eed1e73">&#9670;&#160;</a></span>pow() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t _Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">matrix&lt; _Size, _Size &gt; __cdecl pow </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; _Size, _Size &gt;</td>          <td class="paramname"><span class="paramname"><em>_A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64</td>          <td class="paramname"><span class="paramname"><em>_Power</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>计算矩阵的整数次幂 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Size</td><td>矩阵维度 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A</td><td>输入矩阵 </td></tr>
    <tr><td class="paramname">_Power</td><td>幂指数（正整数） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>矩阵的 _Power 次幂 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>时间复杂度为 O(n^4)，大数值输入可能导致高延迟 </dd></dl>

</div>
</div>
<a id="ga0f8f8860a95bf9d42948ffb961c73cc1" name="ga0f8f8860a95bf9d42948ffb961c73cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f8f8860a95bf9d42948ffb961c73cc1">&#9670;&#160;</a></span>powc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">complex64 __cdecl powc </td>
          <td>(</td>
          <td class="paramtype">complex64</td>          <td class="paramname"><span class="paramname"><em>_X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex64</td>          <td class="paramname"><span class="paramname"><em>_Power</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64</td>          <td class="paramname"><span class="paramname"><em>K_OFFSET</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>计算复数的幂函数（z^w） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_X</td><td>复数底数值 </td></tr>
    <tr><td class="paramname">_Power</td><td>复数指数值 </td></tr>
    <tr><td class="paramname">K_OFFSET</td><td>分支选择偏移量（默认为0） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>复数的幂结果 </dd></dl>

</div>
</div>
<a id="ga620a9b7af7ede23efc704b31d3302a98" name="ga620a9b7af7ede23efc704b31d3302a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga620a9b7af7ede23efc704b31d3302a98">&#9670;&#160;</a></span>sqrt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float64 __cdecl sqrt </td>
          <td>(</td>
          <td class="paramtype">float64</td>          <td class="paramname"><span class="paramname"><em>_X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>计算平方根（√x） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_X</td><td>被开方数（必须 ≥ 0） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>_X 的平方根 </dd></dl>

</div>
</div>
<a id="ga8929fcda428dc4db72382cdd0034db68" name="ga8929fcda428dc4db72382cdd0034db68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8929fcda428dc4db72382cdd0034db68">&#9670;&#160;</a></span>sqrt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">fvec&lt; N &gt; __cdecl sqrt </td>
          <td>(</td>
          <td class="paramtype">fvec&lt; N &gt;</td>          <td class="paramname"><span class="paramname"><em>_X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>计算向量各元素的平方根 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>向量维度 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_X</td><td>输入向量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>各元素平方根结果向量 </dd></dl>

</div>
</div>
<a id="ga3a9eb9588318ba54a783ef5a405ede0c" name="ga3a9eb9588318ba54a783ef5a405ede0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a9eb9588318ba54a783ef5a405ede0c">&#9670;&#160;</a></span>sqrtc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; complex64, 2 &gt; __cdecl sqrtc </td>
          <td>(</td>
          <td class="paramtype">complex64</td>          <td class="paramname"><span class="paramname"><em>_X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>计算复数的平方根 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_X</td><td>复数被开方数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含两个平方根的数组 </dd></dl>

</div>
</div>
<a id="gacd80ab4931b4662c0da0b38dc57525b2" name="gacd80ab4931b4662c0da0b38dc57525b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd80ab4931b4662c0da0b38dc57525b2">&#9670;&#160;</a></span>yroot() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float64 __cdecl yroot </td>
          <td>(</td>
          <td class="paramtype">float64</td>          <td class="paramname"><span class="paramname"><em>_X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64</td>          <td class="paramname"><span class="paramname"><em>_Expo</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>计算任意次方根（ʸ√x） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_X</td><td>被开方数 </td></tr>
    <tr><td class="paramname">_Expo</td><td>根指数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>_X 的 _Expo 次方根 </dd></dl>

</div>
</div>
<a id="gafdb4903d2360c421a7a71d9897a286a4" name="gafdb4903d2360c421a7a71d9897a286a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdb4903d2360c421a7a71d9897a286a4">&#9670;&#160;</a></span>yroot() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">fvec&lt; N &gt; __cdecl yroot </td>
          <td>(</td>
          <td class="paramtype">fvec&lt; N &gt;</td>          <td class="paramname"><span class="paramname"><em>_X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float64</td>          <td class="paramname"><span class="paramname"><em>_Expo</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>计算向量各元素的标量指数方根 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>向量维度 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_X</td><td>输入向量 </td></tr>
    <tr><td class="paramname">_Expo</td><td>根指数（标量） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>各元素方根结果向量 </dd></dl>

</div>
</div>
<a id="ga359f10f1db3541e89089f776bbc46343" name="ga359f10f1db3541e89089f776bbc46343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga359f10f1db3541e89089f776bbc46343">&#9670;&#160;</a></span>yroot() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">fvec&lt; N &gt; __cdecl yroot </td>
          <td>(</td>
          <td class="paramtype">fvec&lt; N &gt;</td>          <td class="paramname"><span class="paramname"><em>_X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fvec&lt; N &gt;</td>          <td class="paramname"><span class="paramname"><em>_Expo</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>计算向量各元素的向量指数方根 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>向量维度 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_X</td><td>输入向量 </td></tr>
    <tr><td class="paramname">_Expo</td><td>根指数向量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>各元素方根结果向量 </dd></dl>

</div>
</div>
<a id="ga7042401014af7fec0717ef674695921f" name="ga7042401014af7fec0717ef674695921f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7042401014af7fec0717ef674695921f">&#9670;&#160;</a></span>yrootc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; complex64 &gt; __cdecl yrootc </td>
          <td>(</td>
          <td class="paramtype">complex64</td>          <td class="paramname"><span class="paramname"><em>_X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex64</td>          <td class="paramname"><span class="paramname"><em>_Expo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64</td>          <td class="paramname"><span class="paramname"><em>K_OFFSET</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>计算复数的任意次方根 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_X</td><td>复数被开方数 </td></tr>
    <tr><td class="paramname">_Expo</td><td>复数根指数 </td></tr>
    <tr><td class="paramname">K_OFFSET</td><td>分支选择偏移量（默认为0） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>复数根的结果向量 </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.14.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <!-- <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li> -->
  </ul>
</div>
</body>
</html>
